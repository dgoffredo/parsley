Grammar  ::=  rules:(Rule (BLANK_LINE Rule)*)

Rule  ::=  ignore:("ignore"?) name:IDENTIFIER ("::="|":") pattern:Pattern

Pattern  ::=  alternation:Alternation      (* one from multiple options *)
          |   concatenation:Concatenation  (* one or more subpatterns *)

Alternation  ::=  patterns:(PatternTerm ("|" PatternTerm)+)

Concatenation  ::=  patterns:(PatternTerm+)

PatternTerm  ::=  bound:BoundPatternTerm
              |   unbound:QuantifiedPatternTerm

BoundPatternTerm  ::=  name:IDENTIFIER ":" term:QuantifiedPatternTerm

QuantifiedPatternTerm  ::=  star:(UnquantifiedPatternTerm "*")
                        |   plus:(UnquantifiedPatternTerm "+")
                        |   question:(UnquantifiedPatternTerm "?")
                        |   term:UnquantifiedPatternTerm

UnquantifiedPatternTerm  ::=  literal:STRING
                          |   regex:REGEX
                          |   rule:IDENTIFIER
                          |   empty:EMPTY
                          |   "(" pattern:Pattern ")"

IDENTIFIER  ::=  /[a-zA-Z_][0-9a-zA-Z_]*/      (* e.g. foo5 but not 5foo *)

STRING  ::=  /"([^\\"]|\\.)*"/                 (* e.g. "\"with\" escape" *)

REGEX  ::=  /\/([^\\\/]|\\.)*\//               (* e.g. /foo|ba[rz]/ *)

EMPTY  ::=  /\(\)/                             (* () matches nothing *)

ignore COMMENT  ::=  /\(\*([^*]|\*[^)])*\*\)/  (* e.g. this comment *)

(* We want to simulataneously treat a blank line as a rule delimiter, but
    also otherwise ignore whitespace. To do that, stretches of whitespace
    have to be categorized by their adjacency to non-whitespace. *)

BLANK_LINE  ::=  /\s*\n\s*\n\s*/

ignore WS_LEFT  ::=  /\s+(?=\S)/

ignore WS_END  ::=  /\s+$/